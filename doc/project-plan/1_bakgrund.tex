% BAKGRUNDENS UPPGIFT?: Motivera behovet att visualiseringsverktyg för fuzzing
% (fuzzing används slarvigt, inkludera tex concolic testing)

Vi läser ofta källkod för att förstå program, men ibland är det gynnsamt att istället betrakta
maskinkoden direkt. Detta kan vara för att
\begin{itemize}
  \item utesluta påverkan av kompilatorbuggar som ger oväntad maskinkod
  \item se hur undefined behavior (UB) har utnyttjats av kompilatorn
  \item källkoden inte är tillgänglig
\end{itemize}

Det finns en uppsjö av metoder vi kan använda för att analysera en exekverbar binär. Vi kan bland
annat
\todo{källhänvisa}
\begin{enumerate}
  \item disassemblera binären och läsa dess funktioner för att förstå vad de gör.
  \item dekompilera assemblykoden med ett verktyg som ger högnivåpseudokod, som vi kan läsa.
  \item köra binären på speciella testfall och jämföra svaret med vad vi förväntar oss. Om
    programmet implementerar en specifikation kan vi använda en existerande testsamling.
  \item fuzztesta binären, alltså automatiskt generera testfall tills ett orsakar en crash eller
    annat dåligt beteende i binären. Många fuzztestmotorer skapar testfall med en evolutionär
    algoritm, och många använder instrumentering över vilka programhopp som tas för att bedöma
    testfalls nyttighet.
  \item använda concolic testing, alltså fuzzing där en SMT solver genererar nya testfall genom att
    lösa för testfall som orsakar annorlunda programhopp.
  \item stega igenom programmet i en debugger för att se exakt vad programmet gör med viss input.
\end{enumerate}

För att förstå programmet allmänt behöver vår förståelse vara både \textit{korrekt} och
\textit{abstrakt}, där vi med \textit{korrekt} menar att vi aldrig drar felaktiga slutsatser och med
\textit{abstrakt} menar att vi kan resonera om programmet generellt i motsats till att resonera om en
specifik konkret indata i taget.

Metod 1-2, att läsa kod, kan ge oss en \textit{abstrakt} förståelse av vad programmet gör, men för
att verifiera att vi inte resonerat fel behöver vi kunna testa hypoteser vilket kräver att vi köra
programet. Vi kan inte bilda en \textit{korrekt} förståelse genom att enbart läsa kod.

Metod 3-5, att köra programmet på testfall, ger oss framförallt en black-box-förståelse av
programmet. Att vi har tillgång till binären och exekveringsmiljön används endast som ett verktyg
för att generera nya testfall. Fuzzing och concolic testing kan köras helautomatiskt och är
\textit{korrekta}. Men ofta är en tillräckligt täckande sökning av indatarummet omöjlig, och då kan
den automatiska analysen ha missat ett kvalitativt annorlunda beteende. Dessutom ger en omfattande
uppsättning indata-utdata-par inte användaren samma information som källkoden ger. Därmed är
helautomatiska analysmetoder inte \textit{abstrakta}. Notera att det inte nödvändigtvis tyder på en
brist i den automatiska analysen att ett kvalitativt annorlunda beteende missas, för det gömda
beteendet skulle kunna vara en konsekvens av komplicerad kod, som till exempel ett hoppvilkor
beroende på en kryptografisk hash av indatan. Men en analysmetod borde kunna peka ut var dess
förståelse tar slut, snarare än att utelämna detta fullständigt vilket är vad avsaknaden av testfall
visar sig som.

Med metod 6, i en debugger, kan användaren följa exekveringen för en viss indata utan att riskera
att missförstå hur datan transformeras. Om användaren har ett oändligt tålamod kan de göra detta om
och om igen för olika indata genererade med till exempel fuzzing. Varje genomstegning ger
information om koden som behandlar indatan men också viss information om övrig kod -- till exempel
kan ett svårtaget hopp indikera en plats för användaren att rikta sin uppmärksamhet mot. Detta ger
en både \textit{korrekt} och \textit{abstrakt} förståelse, men med en orimlig manuell arbetsbörda
för användaren.

En helautomatisk \textit{korrekt} metod kan ge en \textit{abstrakt} förståelse om processens förlopp
visualiseras för användaren. Valet mellan manuell arbetsbörda som ger djup förståelse och en
testfallsgenerationsdriven process som ger översiktlig förståelse kan genomföras av användaren om
verktygen stödjer hela spektrat.
